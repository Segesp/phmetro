#include <ESP8266WiFi.h>         // Librer√≠a WiFi para ESP8266
#include <ESP8266HTTPClient.h>   // Librer√≠a HTTPClient para ESP8266
#include <WiFiClient.h>          // Necesaria para la nueva firma de HTTPClient::begin()
#include <ArduinoJson.h>         // Para manejo JSON m√°s robusto (opcional)

// ========== CONFIGURACI√ìN WIFI ==========
const char* ssid       = "SEGOVIA3";
const char* password   = "76840574";

// ========== CONFIGURACI√ìN SERVIDOR ==========
const char* serverUrl  = "https://phmetro-p5w79503p-segesps-projects.vercel.app/api/ph-data";

// ========== CONFIGURACI√ìN SENSOR pH ==========
const int phPin = A0;                    // Pin anal√≥gico donde est√° conectado el sensor
const float phMin = 0.0;                 // pH m√≠nimo del sensor
const float phMax = 14.0;                // pH m√°ximo del sensor
const int adcMin = 0;                    // Valor ADC m√≠nimo (0V)
const int adcMax = 1023;                 // Valor ADC m√°ximo (3.3V en ESP8266)

// ========== CONFIGURACI√ìN TIMING ==========
const unsigned long sendInterval = 15000;  // Intervalo de env√≠o en ms (15 segundos para pruebas)
const int maxRetries = 3;                   // M√°ximo n√∫mero de reintentos
const int retryDelay = 3000;                // Delay entre reintentos en ms (reducido para pruebas)

// ========== VARIABLES GLOBALES ==========
WiFiClient wifiClient;
unsigned long lastSendTime = 0;
int consecutiveErrors = 0;

void setup() {
  Serial.begin(115200);
  delay(2000); // Dar tiempo para que se abra el monitor serial
  
  Serial.println("\n" + String('=') * 50);
  Serial.println("üöÄ INICIANDO pH METRO ESP8266 - MODO DEBUG");
  Serial.println(String('=') * 50);
  Serial.println("üß™ MODO SIMULACI√ìN ACTIVADO");
  Serial.println("üìä Generando datos de prueba sint√©ticos");
  Serial.println("üîç Monitor detallado de transmisi√≥n habilitado");
  Serial.println("");
  
  // Mostrar informaci√≥n del sistema
  printSystemInfo();
  
  // Configurar pin del sensor (aunque no se use en simulaci√≥n)
  pinMode(phPin, INPUT);
  
  // Inicializar generador de n√∫meros aleatorios
  randomSeed(analogRead(A0) + millis());
  
  // Conectar a WiFi
  connectToWiFi();
  
  Serial.println(String('=') * 50);
  Serial.println("‚úÖ SISTEMA LISTO PARA TRANSMISI√ìN");
  Serial.println(String('=') * 50);
  Serial.print("‚è∞ Intervalo de env√≠o: ");
  Serial.print(sendInterval / 1000);
  Serial.println(" segundos");
  Serial.print("üåê Servidor destino: ");
  Serial.println(serverUrl);
  Serial.println("üî¨ Rango pH simulado: 6.0-8.5");
  Serial.println("üì° Iniciando transmisi√≥n de datos...");
  Serial.println(String('-') * 50);
}

void loop() {
  unsigned long currentTime = millis();
  
  // Verificar si es tiempo de enviar datos
  if (currentTime - lastSendTime >= sendInterval) {
    Serial.println("\n" + String('‚ñà') * 30);
    Serial.println("üîÑ INICIANDO NUEVA TRANSMISI√ìN");
    Serial.println(String('‚ñà') * 30);
    
    // Mostrar timestamp
    Serial.print("üïê Tiempo de sistema: ");
    Serial.print(currentTime / 1000);
    Serial.println(" segundos");
    
    // Leer pH del sensor
    Serial.println("\nüìä GENERANDO DATOS DE pH:");
    float phValue = readPH();
    
    // Mostrar datos detallados antes del env√≠o
    printDataDetails(phValue);
    
    // Validar lectura
    if (isValidPH(phValue)) {
      Serial.println("\nüì° INICIANDO TRANSMISI√ìN A SERVIDOR:");
      Serial.println(String('-') * 40);
      
      // Enviar datos al servidor
      bool success = sendPhData(phValue);
      
      Serial.println(String('-') * 40);
      if (success) {
        consecutiveErrors = 0;
        Serial.println("‚úÖ TRANSMISI√ìN COMPLETADA EXITOSAMENTE");
        Serial.println("üéØ DATOS CONFIRMADOS EN SERVIDOR");
        printTransmissionSummary(true);
      } else {
        consecutiveErrors++;
        Serial.println("‚ùå TRANSMISI√ìN FALLIDA");
        Serial.print("‚ö†Ô∏è Errores consecutivos: ");
        Serial.println(consecutiveErrors);
        printTransmissionSummary(false);
        
        // Si hay muchos errores consecutivos, reiniciar WiFi
        if (consecutiveErrors >= 5) {
          Serial.println("\nüö® DEMASIADOS ERRORES CONSECUTIVOS");
          Serial.println("üîÑ Reiniciando conexi√≥n WiFi...");
          connectToWiFi();
          consecutiveErrors = 0;
        }
      }
    } else {
      Serial.println("\n‚ö†Ô∏è LECTURA DE pH INV√ÅLIDA");
      Serial.print("‚ùå Valor rechazado: ");
      Serial.println(phValue);
    }
    
    lastSendTime = currentTime;
    
    Serial.println(String('‚ñà') * 30);
    Serial.print("‚è≥ PR√ìXIMA TRANSMISI√ìN EN: ");
    Serial.print(sendInterval / 1000);
    Serial.println(" SEGUNDOS");
    Serial.println(String('‚ñà') * 30);
  }
  
  // Peque√±o delay para no sobrecargar el loop
  delay(100);
}

// ========== FUNCIONES ==========

void connectToWiFi() {
  Serial.print("Conectando a WiFi: ");
  Serial.println(ssid);
  
  WiFi.begin(ssid, password);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n‚úÖ WiFi conectado");
    Serial.print("IP: ");
    Serial.println(WiFi.localIP());
    Serial.print("Se√±al: ");
    Serial.print(WiFi.RSSI());
    Serial.println(" dBm");
  } else {
    Serial.println("\n‚ùå Error conectando WiFi");
    Serial.println("üîÑ Reiniciando en 10 segundos...");
    delay(10000);
    ESP.restart();
  }
}

float readPH() {
  // ========== MODO SIMULACI√ìN - DATOS DE PRUEBA ==========
  Serial.println("üß™ Ejecutando simulador de pH...");
  
  static float basePH = 7.0;  // pH base
  static unsigned long lastChange = 0;
  static float trend = 0.0;
  
  unsigned long currentTime = millis();
  
  // Cambiar la tendencia cada 2 minutos
  if (currentTime - lastChange > 120000) {
    float oldTrend = trend;
    trend = (random(-30, 31) / 100.0); // Cambio entre -0.3 y +0.3
    lastChange = currentTime;
    Serial.print("üìà Cambio de tendencia: ");
    Serial.print(oldTrend, 3);
    Serial.print(" ‚Üí ");
    Serial.println(trend, 3);
  }
  
  // Simular variaciones naturales
  float timeVariation = sin(currentTime / 30000.0) * 0.2;  // Variaci√≥n temporal
  float randomNoise = (random(-10, 11) / 100.0);           // Ruido aleatorio ¬±0.1
  
  // Calcular pH simulado
  float simulatedPH = basePH + trend + timeVariation + randomNoise;
  
  // Mantener en rango realista (6.0 - 8.5)
  simulatedPH = constrain(simulatedPH, 6.0, 8.5);
  
  // Simular lectura ADC para mostrar en logs
  float simulatedADC = map(simulatedPH * 100, phMin * 100, phMax * 100, adcMin, adcMax);
  
  Serial.print("üìä ADC simulado: ");
  Serial.print(simulatedADC, 0);
  Serial.print(" ‚Üí pH calculado: ");
  Serial.print(simulatedPH, 3);
  Serial.print(" (base:");
  Serial.print(basePH, 1);
  Serial.print(" + tendencia:");
  Serial.print(trend, 3);
  Serial.print(" + variaci√≥n:");
  Serial.print(timeVariation, 3);
  Serial.print(" + ruido:");
  Serial.print(randomNoise, 3);
  Serial.println(")");
  
  return simulatedPH;
}

bool isValidPH(float ph) {
  return (ph >= 0.0 && ph <= 14.0);
}

bool sendPhData(float phValue) {
  // Verificar conexi√≥n WiFi
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ùå ERROR: WiFi no conectado");
    Serial.print("üåê Estado WiFi: ");
    Serial.println(WiFi.status());
    return false;
  }
  
  Serial.println("‚úÖ WiFi conectado - Procediendo con transmisi√≥n");
  Serial.print("üì∂ Intensidad de se√±al: ");
  Serial.print(WiFi.RSSI());
  Serial.println(" dBm");
  
  HTTPClient http;
  bool success = false;
  
  // Intentar env√≠o con reintentos
  for (int attempt = 1; attempt <= maxRetries; attempt++) {
    Serial.println(String('‚ñº') * 25);
    Serial.print("üöÄ INTENTO DE TRANSMISI√ìN #");
    Serial.print(attempt);
    Serial.print(" de ");
    Serial.println(maxRetries);
    Serial.println(String('‚ñº') * 25);
    
    // Configurar HTTPClient
    Serial.println("üîß Configurando cliente HTTP...");
    http.begin(wifiClient, serverUrl);
    http.addHeader("Content-Type", "application/json");
    http.addHeader("User-Agent", "ESP8266-pH-Sensor/1.0");
    http.setTimeout(10000); // Timeout de 10 segundos
    Serial.println("‚úÖ Cliente HTTP configurado");
    
    // Construir JSON con datos de simulaci√≥n
    String json = "{\"ph\":";
    json += String(phValue, 2);
    json += ",\"timestamp\":\"";
    json += getISOTime();
    json += "\",\"device\":\"ESP8266\",\"sensor\":\"pH_simulado\",\"mode\":\"simulation\",\"test\":true}";
    
    Serial.println("üì¶ DATOS A TRANSMITIR:");
    Serial.println(String('-') * 30);
    Serial.print("üîó URL destino: ");
    Serial.println(serverUrl);
    Serial.print("üìÑ Content-Type: application/json");
    Serial.print("üìä Tama√±o del payload: ");
    Serial.print(json.length());
    Serial.println(" bytes");
    Serial.println("üìã JSON completo:");
    Serial.println(json);
    Serial.println(String('-') * 30);
    
    // Enviar datos
    Serial.println("üì° TRANSMITIENDO DATOS...");
    unsigned long startTime = millis();
    int httpResponseCode = http.POST(json);
    unsigned long endTime = millis();
    
    Serial.print("‚è±Ô∏è Tiempo de transmisi√≥n: ");
    Serial.print(endTime - startTime);
    Serial.println(" ms");
    
    Serial.println("üì• RESPUESTA DEL SERVIDOR:");
    Serial.println(String('-') * 30);
    Serial.print("üî¢ C√≥digo HTTP: ");
    Serial.print(httpResponseCode);
    
    if (httpResponseCode > 0) {
      String response = http.getString();
      
      if (httpResponseCode == 200) {
        Serial.println(" ‚úÖ OK - Datos recibidos correctamente");
      } else if (httpResponseCode == 201) {
        Serial.println(" ‚úÖ CREATED - Datos creados exitosamente");
      } else if (httpResponseCode >= 400 && httpResponseCode < 500) {
        Serial.println(" ‚ùå ERROR DEL CLIENTE");
      } else if (httpResponseCode >= 500) {
        Serial.println(" ‚ùå ERROR DEL SERVIDOR");
      } else {
        Serial.print(" ‚ö†Ô∏è C√ìDIGO DESCONOCIDO");
      }
      
      Serial.print("üìÑ Respuesta del servidor (");
      Serial.print(response.length());
      Serial.println(" caracteres):");
      Serial.println(response);
      
      if (httpResponseCode == 200 || httpResponseCode == 201) {
        success = true;
        Serial.println("üéØ TRANSMISI√ìN EXITOSA CONFIRMADA");
        break;
      }
    } else {
      Serial.println(" ‚ùå ERROR DE CONEXI√ìN");
      Serial.print("üîç Detalle del error: ");
      Serial.println(http.errorToString(httpResponseCode));
    }
    
    Serial.println(String('-') * 30);
    http.end();
    
    // Si no es el √∫ltimo intento, esperar antes del siguiente
    if (attempt < maxRetries && !success) {
      Serial.print("‚è≥ Esperando ");
      Serial.print(retryDelay / 1000);
      Serial.println(" segundos antes del siguiente intento...");
      
      for (int i = retryDelay / 1000; i > 0; i--) {
        Serial.print(i);
        Serial.print("... ");
        delay(1000);
      }
      Serial.println("üîÑ");
    }
  }
  
  http.end();
  return success;
}

String getISOTime() {
  // Si no tienes RTC o NTP configurado, retorna cadena vac√≠a
  // El servidor usar√° su propio timestamp
  return "";
}

// Funci√≥n para mostrar informaci√≥n del sistema (opcional)
void printSystemInfo() {
  Serial.println("üñ•Ô∏è INFORMACI√ìN DEL SISTEMA:");
  Serial.println(String('-') * 35);
  Serial.print("üÜî Chip ID: 0x");
  Serial.println(ESP.getChipId(), HEX);
  Serial.print("üíæ Flash ID: 0x");
  Serial.println(ESP.getFlashChipId(), HEX);
  Serial.print("‚ö° Frecuencia CPU: ");
  Serial.print(ESP.getCpuFreqMHz());
  Serial.println(" MHz");
  Serial.print("üß† Memoria libre: ");
  Serial.print(ESP.getFreeHeap());
  Serial.println(" bytes");
  Serial.print("üìÅ Tama√±o Sketch: ");
  Serial.print(ESP.getSketchSize());
  Serial.println(" bytes");
  Serial.print("üíΩ Espacio libre: ");
  Serial.print(ESP.getFreeSketchSpace());
  Serial.println(" bytes");
  Serial.println(String('-') * 35);
}

// Funci√≥n para mostrar detalles de los datos antes del env√≠o
void printDataDetails(float phValue) {
  Serial.println("üìã DETALLES DE LOS DATOS:");
  Serial.println(String('-') * 25);
  Serial.print("üìä Valor pH: ");
  Serial.print(phValue, 3);
  Serial.println("");
  Serial.print("üéØ Precisi√≥n: 3 decimales");
  Serial.println("");
  Serial.print("üìè Rango v√°lido: 0.0 - 14.0");
  Serial.println("");
  Serial.print("‚úÖ Estado: ");
  Serial.println(isValidPH(phValue) ? "V√ÅLIDO" : "INV√ÅLIDO");
  
  // Clasificar el pH
  String classification;
  if (phValue < 6.5) classification = "√ÅCIDO";
  else if (phValue > 8.5) classification = "B√ÅSICO";
  else classification = "NEUTRO/√ìPTIMO";
  
  Serial.print("üß™ Clasificaci√≥n: ");
  Serial.println(classification);
  Serial.println(String('-') * 25);
}

// Funci√≥n para mostrar resumen de transmisi√≥n
void printTransmissionSummary(bool success) {
  static int totalTransmissions = 0;
  static int successfulTransmissions = 0;
  
  totalTransmissions++;
  if (success) successfulTransmissions++;
  
  Serial.println("üìà RESUMEN DE TRANSMISIONES:");
  Serial.println(String('-') * 30);
  Serial.print("üìä Total enviadas: ");
  Serial.println(totalTransmissions);
  Serial.print("‚úÖ Exitosas: ");
  Serial.println(successfulTransmissions);
  Serial.print("‚ùå Fallidas: ");
  Serial.println(totalTransmissions - successfulTransmissions);
  Serial.print("üìà Tasa de √©xito: ");
  Serial.print((float)successfulTransmissions / totalTransmissions * 100, 1);
  Serial.println("%");
  Serial.println(String('-') * 30);
}

// Funci√≥n para mostrar estado de la simulaci√≥n
void printSimulationStatus() {
  static int dataCount = 0;
  dataCount++;
  
  Serial.println("üß™ ESTADO DE SIMULACI√ìN:");
  Serial.println(String('-') * 25);
  Serial.print("üî¢ Datos simulados enviados: ");
  Serial.println(dataCount);
  Serial.print("‚è∞ Pr√≥xima lectura en: ");
  Serial.print(sendInterval / 1000);
  Serial.println(" segundos");
  Serial.print("üîÑ Modo: SIMULACI√ìN CONTINUA");
  Serial.println("");
  Serial.println(String('-') * 25);
}

// Funci√≥n para generar escenarios espec√≠ficos de pH (opcional)
float getScenarioPH(int scenario) {
  switch(scenario) {
    case 1: // pH √°cido
      return 6.2 + (random(0, 31) / 100.0); // 6.2 - 6.5
    case 2: // pH neutro  
      return 6.8 + (random(0, 41) / 100.0); // 6.8 - 7.2
    case 3: // pH b√°sico
      return 7.8 + (random(0, 51) / 100.0); // 7.8 - 8.3
    default:
      return 7.0 + (random(-50, 51) / 100.0); // 6.5 - 7.5
  }
}
